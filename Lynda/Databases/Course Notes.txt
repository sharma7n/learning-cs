Intro / Chapter 1

- What are databases?
	- Problems
		- Size
		- Ease of updating
		- Accuracy
		- Security
		- Redundancy
		- Importance
	- Way to store data that is:
		- Scalable
		- Accessible
		- Accurate
		- Secure
		- Consistent
		- Permanent
	- Structure for data

- Exploring databases and database management systems
	- Database Management Systems
		- Oracle
		- SQL Server
		- MySQL
		- PostgreSQL
		- MongoDB
		- Microsoft Access
	- Most common: Relational DBMS
	- Others: Hierarchical, Network, Object-Oriented, NoSQL
	- Focus on Relational
		- Most widely used
		- Use same principles across all of them
		- Are foundational for other systems
	
- Features of a relational database
	- A database is constructed of one or more tables
	- Tables
		- Columns are strongly typed
		
- Unique values and primary keys
	- Keys uniquely identify a row
	- If generated by the DB, also called synthetic / surrogate key (still primary)
	
- Defining Table Relationships
	- One to Many
		- Foreign Keys do not need to be unique
	- Many to Many (i.e., Multi-link)
		- Create junction / linking table
	- One to One
		- Not very common

- Transactions and the ACID Test
	- Transaction is a combined unit of work. If anything fails, nothing happens.
	- ACID
		- Atomic
		- Consistent
		- Isolated
		- Durable
		
- Introduction to SQL
	- Declarative query lanaguage, not procedural imperative language
	- CRUD: Create (Insert), Read (Select), Update, Delete
	
- Introduction to database modeling
	- Schema is formal description
	- Planning is vital
		- What's the point?
		- Inventory existing stuff: physical items, people, fake databases
		- Entities, like process for determining classes in OO

- Identifying columns and data types
	- Attributes become columns in each table
	- Specify the data type for each column
	- Stricter than a programming language
	- Fixed length is more efficienct
	- Required or optional? (not NULL / NULL)
	- default values
	- pattern matching
	
- Choosing primary keys
	- Natural key: naturally occurs in data (e.g., ISBN number for books)
	- ID: integer, auto-increment

- Composite keys
	- MPK

- Creating relationships
	- One to many
	- Many to many
	- One to one
	- (None)
	
- One to many (many to one)
	- i.e., link
	- Uses the PK of the pointed-to table
	- Pointer has one object, pointed can have multiple
	
- One to one
	- Like an extension of data
	- Watch out for false one-to-one relationships
	
- Many to many
	- i.e., multi-links
	- Cannot represent directly, use an intermediary (join / junction / linking)
	- Table1Table2
	- Watch out for subtle many-to-many relationships
	
- Relationship rules and referential integrity
	- RI: data validation across tables
		- Prevent add/update of non-existing FK
		- Prevent delete of pointed to object, or cascade delete, or cascade nullify
		
- Database Normalization
	
- First Normal Form (1NF)
	- Each column in each table should only contain one value, no repeating groups
	- Creating a new table is usually the correct answer
	
- Second Normal Form (2NF)
	- 1NF + any non-key field should be dependent on the entire primary key
	- Look at other columns and see if they are only dependent on a key part
	
- Third Normal Form (3NF)
	- No non-key field is dependent on another non-key field
	- If data is object.attribute, make new table
	- Also can use calculated columns, or remove calculated column
	
- Database Denormalization
	- Can be done strategically for convenience or performance
	- In most business cases, 3NF is enough
	- Normalization vastly improves data quality
	
- SQL Queries
	- Look up SQL Essential Training
	- SELECT
		- SELECT columns FROM table: reads columns
		- WHERE condition: filter
		- Mostly case-insensitive and whitespace-insensitive
		- Ends with ';' but usually not an issue
		- FROM database.table to prevent namespace collisions
	- WHERE
		- Strings use single quotes
		- Single equal sign to test equality
		- <> for not equal
		- Can use AND or OR
		- IN (a, b, ...)
		- LIKE 'Pattern%'
		- LIKE 'Sm_th'
		- IS NULL / IS NOT NULL
	- ORDER BY
		- Default ascending
		- DESC for descending
		- Multiple orders
	- Aggregate Functions
		- SELECT Count(*)
		- Max, Min, Avg, Sum all operate on columns
		- SELECT Count(*), Color FROM Product GROUP BY Color
		- GROUP BY only makes sense with aggregate functions
	- Joining Tables
		- SELECT ... FROM Employee (INNER) JOIN Department ON Department = Department.Id
		- Can add columns from the joined table in the select
		- Can namespace columns with the same name across tables with Table.Column
		- ON ForeignKey = PrimaryKey
		- Default join is Inner Join - only get back data where there is a match in both tables
		- OUTER JOIN - take ALL of the data from a table, and also show matches
			- LEFT OUTER JOIN - the Left table (i.e., the table with the link)
			- RIGHT OUTER JOIN - the Right table (i.e., the linked table)
			- FULL OUTER JOIN - include all rows for both tables, joining when possible
	- INSERT, UPDATE, and DELETE
		- INSERT INTO table (column1, column2, ...)
		  VALUES (value1, value2, ...)
		- UPDATE
		  SET column = value
		  WHERE condition
		- DELETE FROM table
		  WHERE condition
		- Good practice to turn "Select" into "Delete"
		- CRUD also called Data Manipulation Language
	- Data Definition Language
		- CREATE
			- CREATE table (column definitions)
			- Create Employee
				(EmployeeId INTEGER PRIMARY KEY,
				...
				)
		- ALTER
			- ALTER TABLE ...
			- ADD
		- DROP TABLE table
	- Data Control
		- GRANT
		- REVOKE
		- Out of scope for this course

- Modeling: Indexing and Optimization
	- Index for speed of access (like going to an array index)
	- Clustered index: database is ordered by this column
	- Only 1 clustered index, but can have arbitrary non-clustered indices
		- Non-clustered index is basically an ordered map from a column to the clustered index
		- Only put on the most important fields, indices are expensive
		- Faster reads but slower writes
		- Can be changed without breaking the applications

- Write Conflicts
	- i.e., thread-safety
	- race condition: multiple threads doing similar steps
	- BEGIN TRANSACTION
		interiod code
	  COMMIT
	- Pessimistic locking - lock on begin, unlock on commit
	- Optimistic locking - will detect dirty read and rollback
	- Different DBMSs handle locking differently
	
- Stored Procedures and Injection Attacks
	- Stored Procedures (S-block) are just custom SQL functions
		- CREATE PROCEDURE ProcName()
		  END
		- CALL ProcName
		- CREATE PROCEDURE ProcName(IN ArgName Data Type)
	- SQL Injection
		- Stored Procedures provide a measure of protection here
	
- Desktop Database Systems
	- Microsoft Office
	- FileMaker
	- Simple, easy, provides lots of features
	- Does not scale well
	
- Relational Database Management Systems
	- Oracle
	- DB2
	- SQL Server
	- MySQL
	- All based on E.F. Codd

- XML and Object-Oriented Database System
	- XML
		- BaseX, Sedna, eXist
		- Use XQuery
	- Object-Oriented Database System
		- ORM maps objects to tables and
			- Specific to language
			
- NoSQL Database Systems
	- "Not only SQL"
	- CouchDB, MongoDB, Apache Cassandra, all very different
	- May include...
		- Not using SQL
		- Not using tables
		- No formal schema
		- Web development
		- Large-scale deployment
		- Open source
	- Document Stores
		- Documents instead of rows and columns
		- Examples: CouchDB, MongoDB
	- Key-Value Stores
		- Everything is a key-value pair
		- Examples: Memcached, Riak, Project Voldemort
	- Graph Database
		- Everything stored in small connected nodes, with relations
		- Examples: Neo4j, AllegroGraph
	- Reasons
		- Flexible schema?
		- Vast amounts of data?
		- Value scaling over consistency?
	- Look up NoSQL course
	
- Further courses:
	- SQL Essential Training
	- NoSQL